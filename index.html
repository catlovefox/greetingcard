<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>输入Merry Christmas</title>
  <style>
    :root{
      --bg:#000; --fg:#fff; --muted:rgba(255,255,255,.72);
      --stroke:rgba(255,255,255,.16); --shadow:0 18px 60px rgba(0,0,0,.55);
      --radius:18px;
    }
    *{ box-sizing:border-box; }
    html,body{
      height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family:-apple-system,BlinkMacSystemFont,"PingFang SC","Noto Sans SC","Microsoft YaHei",system-ui,Segoe UI,Roboto,Helvetica,Arial;
    }
    body{ overflow:hidden; }
    #stage{ position:fixed; inset:0; width:100vw; height:100vh; display:block; touch-action:none; }

    video#cam{ position:fixed; width:1px; height:1px; opacity:0; left:-20px; top:-20px; pointer-events:none; }

    #gate{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      padding:24px;
      background:radial-gradient(1200px 700px at 50% 40%, rgba(255,255,255,.08), rgba(0,0,0,1) 62%);
      z-index:10; opacity:1; transition:opacity .45s ease;
    }
    #gate.hide{ opacity:0; pointer-events:none; }

    .card{
      width:min(460px, 92vw);
      background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px 16px 16px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .title{ font-size:16px; letter-spacing:.6px; color:rgba(255,255,255,.92);
      display:flex; align-items:center; gap:10px; margin:0 0 10px; }
    .badge{ width:10px; height:10px; border-radius:50%;
      background:rgba(255,255,255,.88); box-shadow:0 0 18px rgba(255,255,255,.5); }
    .hint{ margin:0 0 12px; color:var(--muted); font-size:13px; line-height:1.55; }
    .row{ display:flex; gap:10px; align-items:center; }
    input{
      flex:1; background:rgba(0,0,0,.55); color:var(--fg);
      border:1px solid rgba(255,255,255,.18); border-radius:14px;
      padding:12px 12px; font-size:14px; outline:none;
    }
    input::placeholder{ color:rgba(255,255,255,.38); }
    button{
      background:rgba(255,255,255,.92); color:#000; border:none; border-radius:14px;
      padding:12px 14px; font-weight:900; font-size:14px; cursor:pointer;
      box-shadow:0 10px 30px rgba(255,255,255,.14);
    }

    #cornerTip{
      position:fixed; top:max(14px, env(safe-area-inset-top)); left:50%; transform:translateX(-50%);
      z-index:15; opacity:0; transition:opacity .35s ease; pointer-events:auto;
      display:flex; align-items:center; gap:10px; white-space:nowrap;
    }
    #cornerTip.on{ opacity:1; }
    .pill{
      pointer-events:none;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.35);
      color:rgba(255,255,255,.62); box-shadow:0 10px 30px rgba(0,0,0,.4);
      font-size:12px; letter-spacing:.3px; text-shadow:0 2px 16px rgba(0,0,0,.8);
    }
    .pill b{ color:rgba(255,255,255,.88); font-weight:900; }
    .pill.btn{ pointer-events:auto; cursor:pointer; user-select:none; }
    .pill.btn:active{ transform:translateY(1px); }

    #subs{
      position:fixed; left:50%; bottom:max(16px, env(safe-area-inset-bottom)); transform:translateX(-50%);
      width:min(860px, 94vw); z-index:20; pointer-events:none; opacity:0; transition:opacity .22s ease;
    }
    #subs.on{ opacity:1; }
    .subline{
      background:rgba(0,0,0,.64); border:1px solid rgba(255,255,255,.12);
      border-radius:16px; padding:12px 14px; box-shadow:0 14px 50px rgba(0,0,0,.65);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      font-size:15px; line-height:1.6; letter-spacing:.2px; color:rgba(255,255,255,.94);
      text-shadow:0 2px 16px rgba(0,0,0,.9);
      min-height:48px; display:flex; align-items:center;
      transform:translateY(18px); opacity:0;
      transition:transform .32s cubic-bezier(.2,.9,.2,1), opacity .32s ease;
    }
    .subline.enter{ transform:translateY(0); opacity:1; }
    .subline.exit{ transform:translateY(18px); opacity:0; }
    .caret{ display:inline-block; width:10px; margin-left:3px; opacity:.9; animation:blink 1s steps(1) infinite; }
    @keyframes blink { 50%{ opacity:0; } }

    #debug{
      position:fixed; left:12px; bottom:12px; z-index:50;
      font-size:12px; line-height:1.4; padding:10px 10px;
      border-radius:14px; border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.45); color:rgba(255,255,255,.72);
      box-shadow:0 14px 50px rgba(0,0,0,.65);
      display:none; min-width:230px; pointer-events:none;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    }
    #debug.on{ display:block; }
  </style>
</head>

<body>
  <canvas id="stage"></canvas>
  <video id="cam" playsinline muted></video>
  <audio id="bgm" loop preload="auto" src="bgm.mp3"></audio>

  <div id="gate">
    <div class="card">
      <div class="title"><span class="badge"></span>Merry Christmas</div>
      <p class="hint">
        点亮后...<br/>
        试试挥挥手
      </p>
      <div class="row">
        <input id="name" maxlength="12" placeholder="输入名字" />
        <button id="go">点亮</button>
      </div>
    </div>
  </div>

  <div id="cornerTip">
    <span class="pill">拖动：旋转+俯仰 · 轻点：散开</span>
    <span class="pill btn" id="musicToggle">音乐：<b>关</b></span>
    <span class="pill" id="camStatus">摄像头：<b>未开启</b></span>
  </div>

  <div id="subs"><div class="subline" id="subline"></div></div>
  <div id="debug"></div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const canvas = document.getElementById("stage");
    const gate = document.getElementById("gate");
    const goBtn = document.getElementById("go");
    const nameInput = document.getElementById("name");
    const subs = document.getElementById("subs");
    const subline = document.getElementById("subline");
    const cornerTip = document.getElementById("cornerTip");
    const camEl = document.getElementById("cam");
    const camStatus = document.getElementById("camStatus");
    const bgm = document.getElementById("bgm");
    const musicToggle = document.getElementById("musicToggle");
    const debugEl = document.getElementById("debug");

    const DEBUG = new URLSearchParams(location.search).has("debug");
    if (DEBUG) debugEl.classList.add("on");

    const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));

    async function showSubtitle(text, typeSpeed=28, hold=850){
      subs.classList.add("on");
      subline.classList.remove("exit");
      subline.classList.add("enter");
      subline.innerHTML = "";
      await sleep(200);

      const caret = document.createElement("span");
      caret.className = "caret";
      caret.textContent = "▍";

      for(let i=0;i<text.length;i++){
        subline.textContent = text.slice(0, i+1);
        subline.appendChild(caret);
        await sleep(typeSpeed);
      }
      subline.textContent = text;
      await sleep(hold);

      subline.classList.remove("enter");
      subline.classList.add("exit");
      await sleep(320);
    }

    // ========= 背景音乐（必须用户手势触发） =========
    let musicOn = false;

    function setMusicUI(on){
      musicOn = on;
      if(!musicToggle) return;
      musicToggle.innerHTML = `音乐：<b>${on ? "开" : "关"}</b>`;
      const b = musicToggle.querySelector("b");
      if(b) b.style.color = on ? "rgba(120,255,190,.92)" : "rgba(255,255,255,.88)";
    }

    async function tryPlayMusic(){
      if(!bgm) return false;
      bgm.volume = 0.32;
      bgm.loop = true;
      try{
        await bgm.play();
        setMusicUI(true);
        return true;
      }catch(_){
        setMusicUI(false);
        return false;
      }
    }

    function stopMusic(){
      if(!bgm) return;
      try{ bgm.pause(); }catch(_){}
      setMusicUI(false);
    }

    if(musicToggle){
      musicToggle.addEventListener("click", async (e)=>{
        e.preventDefault(); e.stopPropagation();
        if(musicOn) stopMusic();
        else await tryPlayMusic();
      }, { passive:false });
    }

    async function hideSubs(){
      subline.classList.remove("enter");
      subline.classList.add("exit");
      await sleep(220);
      subs.classList.remove("on");
    }

    // ========= 摄像头（可选） =========
    const cam = {
      enabled:false, ready:false, stream:null,
      w:120, h:90, c:null, ctx:null, prev:null,
      baseline:0, thr:16, lastMotion:0, lastBias:0,
    };

    function setCamStatus(text, ok=false){
      camStatus.innerHTML = `摄像头：<b>${text}</b>`;
      const b = camStatus.querySelector("b");
      b.style.color = ok ? "rgba(120,255,190,.92)" : "rgba(255,255,255,.88)";
    }

    async function startCamera(){
      if(!navigator.mediaDevices?.getUserMedia){ setCamStatus("不支持", false); return false; }
      if(!window.isSecureContext){ setCamStatus("需HTTPS", false); return false; }
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video:{ facingMode:"user", width:{ideal:640}, height:{ideal:480} },
          audio:false
        });
        cam.stream = stream;
        camEl.srcObject = stream;
        await camEl.play();

        cam.c = document.createElement("canvas");
        cam.c.width = cam.w; cam.c.height = cam.h;
        cam.ctx = cam.c.getContext("2d", { willReadFrequently:true });
        cam.prev = new Uint8Array(cam.w * cam.h);

        cam.enabled = true; cam.ready = true;
        cam.baseline = 0; cam.thr = 16;
        setCamStatus("已开启", true);
        return true;
      }catch(_){
        setCamStatus("失败/拒绝", false);
        cam.enabled = false; cam.ready = false;
        return false;
      }
    }

    function detectMotion(){
      if(!cam.ready || !cam.enabled) return { motion:0, bias:0 };
      cam.ctx.drawImage(camEl, 0, 0, cam.w, cam.h);
      const data = cam.ctx.getImageData(0,0,cam.w,cam.h).data;

      let sum=0, sumL=0, sumR=0;
      const step=2;
      for(let y=0;y<cam.h;y+=step){
        for(let x=0;x<cam.w;x+=step){
          const idx = y*cam.w + x;
          const p = idx*4;
          const lum = (data[p]+data[p+1]+data[p+2])/3;
          const prev = cam.prev[idx] || 0;
          const diff = Math.abs(lum - prev);
          cam.prev[idx] = lum;
          sum += diff;
          if(x < cam.w/2) sumL += diff; else sumR += diff;
        }
      }
      const samples = Math.ceil(cam.h/step) * Math.ceil(cam.w/step);
      const motion = sum / samples;
      const bias = sum > 1 ? (sumR - sumL) / sum : 0;

      cam.baseline = cam.baseline*0.94 + motion*0.06;
      cam.thr = Math.max(10.0, cam.baseline + 6.2);
      cam.lastMotion = motion;
      cam.lastBias = bias;
      return { motion, bias };
    }

    // ========= Three.js =========
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.setClearColor(0x000000, 1);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 14, 44);

    const camera3 = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 120);
    camera3.position.set(0, 1.05, 7.8);

    const root = new THREE.Group();
    root.scale.setScalar(1.05);
    root.rotation.set(-0.10, 0.35, 0);
    scene.add(root);

    scene.add(new THREE.AmbientLight(0xffffff, 0.22));

    // --- 生成点云数据 ---
    const HEIGHT = 4.6, LAYERS = 7;
    const treeCols = ["#0B3D0B","#144514","#006400"].map(s=>new THREE.Color(s));
    const decorCols = ["#FFD36A","#D4AF37","#8B0000","#6AA7FF","#FF4FD8"].map(s=>new THREE.Color(s));
    const trunkCol = new THREE.Color("#3a241f");
    const ribbonCol = new THREE.Color("#D4AF37");
    const snowCol = new THREE.Color("#ffffff");

    function randn(){
      let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return Math.sqrt(-2.0*Math.log(u))*Math.cos(2.0*Math.PI*v);
    }

    // kind: 0 tree / 1 decor / 2 ribbon / 3 trunk / 4 snow
    const P=[], C=[], S=[], D=[], K=[], A=[], SP=[];
    function addPoint(x,y,z, color, scale, kind, alpha, speed=0){
      P.push(x,y,z);
      C.push(color.r,color.g,color.b);
      S.push(scale);
      const dir = new THREE.Vector3(x,y,z).normalize();
      D.push(dir.x,dir.y,dir.z);
      K.push(kind);
      A.push(alpha);
      SP.push(speed);
    }

    for(let i=0;i<12000;i++){
      const h = Math.random();
      const base_r = (1 - h);
      const layer_cycle = (h * LAYERS) % 1;
      const r = base_r * 0.72 * (0.38 + 0.62 * Math.pow(1 - layer_cycle, 0.7));
      const theta = Math.random()*Math.PI*2;
      const x = r*Math.cos(theta) + randn()*0.05;
      const z = r*Math.sin(theta) + randn()*0.05;
      const y = (h - 0.5) * HEIGHT;
      const col = treeCols[(Math.random()*treeCols.length)|0];
      addPoint(x,y,z,col,0.7 + Math.random()*1.35,0.0,0.95);
    }

    for(let i=0;i<1500;i++){
      const y = (-0.72 + Math.random()*0.28) * HEIGHT;
      const r = 0.12, t = Math.random()*Math.PI*2;
      addPoint(Math.cos(t)*r + randn()*0.012, y, Math.sin(t)*r + randn()*0.012, trunkCol, 1.35, 3.0, 1.0);
    }

    for(let i=0;i<1100;i++){
      const h = Math.random()*0.97;
      const base_r = (1 - h);
      const layer_cycle = (h * LAYERS) % 1;
      const r = base_r * 0.76 * (0.36 + 0.64 * Math.pow(1 - layer_cycle, 0.72));
      const theta = Math.random()*Math.PI*2;
      const x = r*Math.cos(theta), z = r*Math.sin(theta), y = (h - 0.5)*HEIGHT;
      const col = decorCols[(Math.random()*decorCols.length)|0];
      addPoint(x,y,z,col, 1.55 + Math.random()*1.6, 1.0, 1.0);
    }

    const ribbonN = 8200;
    for(let i=0;i<ribbonN;i++){
      const h = (i/(ribbonN-1))*0.97;
      const base_r = (1 - h) * 0.78;
      const theta = 10.7 * Math.PI * h;
      addPoint(base_r*Math.cos(theta), (h - 0.5)*HEIGHT, base_r*Math.sin(theta), ribbonCol, 1.1, 2.0, 0.92);
    }

    for(let i=0;i<520;i++){
      const x = (Math.random()*2 - 1) * 1.45;
      const z = (Math.random()*2 - 1) * 1.45;
      const y0 = (-1.05 + Math.random()*2.55) * (HEIGHT*0.55);
      const speed = 0.26 + Math.random()*0.70;
      addPoint(x,y0,z,snowCol, 0.6 + Math.random()*1.6, 4.0, 0.55 + Math.random()*0.35, speed);
    }

    const geometry = new THREE.BufferGeometry();
    const posAttr = new THREE.BufferAttribute(new Float32Array(P), 3);
    geometry.setAttribute("position", posAttr);
    geometry.setAttribute("aBase", posAttr);
    geometry.setAttribute("aColor", new THREE.BufferAttribute(new Float32Array(C), 3));
    geometry.setAttribute("aScale", new THREE.BufferAttribute(new Float32Array(S), 1));
    geometry.setAttribute("aDir",   new THREE.BufferAttribute(new Float32Array(D), 3));
    geometry.setAttribute("aKind",  new THREE.BufferAttribute(new Float32Array(K), 1));
    geometry.setAttribute("aAlpha", new THREE.BufferAttribute(new Float32Array(A), 1));
    geometry.setAttribute("aSpeed", new THREE.BufferAttribute(new Float32Array(SP), 1));
    geometry.computeBoundingSphere();

    const uniforms = {
uTime:{value:0},
      uSize:{value:6.2},
      uSpread:{value:0},   // 0=聚拢 1=散开（由挥手/点击驱动）
      uFadeIn:{value:0},
      uFlash:{value:0}
    
      uHueShift:{value:0},  // 旋转驱动的色相偏移
    };

    const material = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      blending:THREE.AdditiveBlending,
      uniforms,
      vertexShader:`
        attribute vec3 aBase;
        attribute vec3 aColor;
        attribute float aScale;
        attribute vec3 aDir;
        attribute float aKind;
        attribute float aAlpha;
        attribute float aSpeed;

        varying vec3 vColor;
        varying float vTw;
        varying float vAlpha;
        varying float vKind;
        varying float vWave;

        uniform float uTime;
        uniform float uSize;
        uniform float uSpread;
        uniform float uFadeIn;
        uniform float uFlash;

        void main(){
          vColor = aColor;
          vKind = aKind;
          vAlpha = aAlpha;

          float seed = aBase.y*2.6 + aBase.x*3.1 + aBase.z*2.9;
          float twBase = 0.55 + 0.45 * sin(uTime*1.7 + seed);

          float amp = 0.22;
          if (aKind < 0.5) amp = 0.22;
          else if (aKind < 1.5) amp = 0.55;
          else if (aKind < 2.5) amp = 0.40;
          else if (aKind < 3.5) amp = 0.12;
          else amp = 0.14;

          vTw = 0.78 + twBase * amp + uFlash*0.10;

          // 丝带流动波纹（只给 kind=2）
          float wave = 0.5 + 0.5 * sin(uTime*5.2 + aBase.y*7.0 + seed*0.7);
          vWave = (aKind > 1.5 && aKind < 2.5) ? wave : 0.0;

          vec3 p = aBase;

          // 雪花下落
          if (aKind > 3.5) {
            float fall = mod(uTime * aSpeed, 6.0);
            p.y = aBase.y - fall;
            if (p.y < -3.45) p.y += 6.0;

            // 轻微受“散开”影响，增强动感（很轻）
            p += aDir * (uSpread * 0.18);
          } else {
            // 挥手/点击散开，不挥就聚回去
            float s = uSpread;

            // 丝带散开稍弱一点，否则像断掉
            if (aKind > 1.5 && aKind < 2.5) s *= 0.75;

                        // —— 消散：不是单纯膨胀，而是随机飘散 + 轻微涡旋；聚拢：s 下降会自然回到 aBase ——
            float r1 = fract(sin(seed*12.9898) * 43758.5453);
            float r2 = fract(sin((seed+1.234)*78.233) * 43758.5453);
            float r3 = fract(sin((seed+4.567)*39.425) * 43758.5453);
            vec3 rnd = normalize(vec3(r1-0.5, r2-0.5, r3-0.5) + 0.0001);
            vec3 tangent = normalize(vec3(-aBase.z, 0.0, aBase.x) + 0.0001);
            vec3 swirl = normalize(cross(rnd, vec3(0.0,1.0,0.0)) + 0.0001);

            float kindAmp = 1.0;
            if (aKind < 0.5) kindAmp = 1.00;        // tree
            else if (aKind < 1.5) kindAmp = 1.25;   // decor 更散一点
            else if (aKind < 2.5) kindAmp = 0.92;   // ribbon 稍克制
            else if (aKind < 3.5) kindAmp = 0.45;   // trunk 很轻

            float drift = 0.70 + 0.30 * sin(uTime*2.3 + seed*1.7);
            vec3 scatterDir = normalize(rnd*0.85 + swirl*0.45 + tangent*0.35 + aDir*0.15 + vec3(0.0,0.22,0.0));
            vec3 scattered = aBase + scatterDir * (s * 2.35 * kindAmp * drift);
            p = mix(aBase, scattered, s);
// 丝带沿切线轻轻“滑动”，更像流动
            if (aKind > 1.5 && aKind < 2.5) {
              vec3 tangent = normalize(vec3(-aBase.z, 0.0, aBase.x));
              p += tangent * (0.03 * sin(uTime*2.2 + aBase.y*6.0));
            }
          }

          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          float distScale = 280.0 / max(1.0, -mvPosition.z);

          float ps = aScale * uSize * distScale * vTw * uFadeIn;

          // 只把丝带(kind=2)变细
          if (aKind > 1.5 && aKind < 2.5) {
            ps *= 0.52;
            gl_PointSize = clamp(ps, 1.0, 9.0);
          } else {
            gl_PointSize = clamp(ps, 1.0, 12.0);
          }

          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader:`
        precision highp float;

        varying vec3 vColor;
        varying float vTw;
        varying float vAlpha;
        varying float vKind;
        varying float vWave;

        uniform float uFadeIn;
        uniform float uFlash;
        uniform float uHueShift;

        
        // Hue rotation (RGB) around luminance axis
        vec3 hueRotate(vec3 c, float a){
          float s = sin(a);
          float co = cos(a);
          mat3 m = mat3(
            0.213 + co*0.787 - s*0.213,  0.715 - co*0.715 - s*0.715,  0.072 - co*0.072 + s*0.928,
            0.213 - co*0.213 + s*0.143,  0.715 + co*0.285 + s*0.140,  0.072 - co*0.072 - s*0.283,
            0.213 - co*0.213 - s*0.787,  0.715 - co*0.715 + s*0.715,  0.072 + co*0.928 + s*0.072
          );
          return m * c;
        }
void main(){
          vec2 uv = gl_PointCoord.xy - 0.5;
          float d = length(uv);

          float isRibbon = step(1.5, vKind) * step(vKind, 2.5);

          // 默认粒子光型
          float coreA = smoothstep(0.26, 0.0, d);
          float haloA = smoothstep(0.62, 0.30, d) * 0.16;

          // 丝带更细更“线”
          float coreR = smoothstep(0.18, 0.0, d);
          float haloR = smoothstep(0.50, 0.36, d) * 0.09;

          float core = mix(coreA, coreR, isRibbon);
          float halo = mix(haloA, haloR, isRibbon);

          float a = (core * 0.92 + halo) * vAlpha * (0.78 + vTw*0.32) * uFadeIn;

          float bright = 1.0;
          if (vKind > 0.5 && vKind < 1.5) bright = 1.55;     // decor
          else if (vKind > 1.5 && vKind < 2.5) bright = 1.20; // ribbon
          else if (vKind > 2.5 && vKind < 3.5) bright = 0.75; // trunk
          else if (vKind > 3.5) bright = 1.05;               // snow

          vec3 col = vColor * bright * (1.0 + uFlash*0.18) * 1.25;

          // 旋转时变色：树/装饰/丝带/雪花都跟着变，树干保持原色
          if (!(vKind > 2.5 && vKind < 3.5)) {
            float hue = uHueShift;
            // 丝带更“流彩”一点
            hue += isRibbon * (0.25 + 0.35*vWave);
            col = hueRotate(col, hue);
          }


          // 丝带“流动”：亮度带跑动
          float flow = 0.72 + 0.70 * vWave; // 提高后会更像跑马灯
          a *= mix(1.0, flow, isRibbon);
          col *= mix(1.0, 0.90 + 0.35*vWave, isRibbon);

          if (a < 0.0035) discard;
          gl_FragColor = vec4(col, a);
        }
      `
    });

    // 如果 shader 写错，直接在控制台看到报错，不至于“整页没反应”
    material.onError = (e)=>console.error("Shader error:", e);

    const points = new THREE.Points(geometry, material);
    points.frustumCulled = false;
    root.add(points);

    const star = new THREE.Mesh(
      new THREE.SphereGeometry(0.07, 16, 16),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    star.position.set(0, HEIGHT*0.52 + 0.30, 0);
    root.add(star);

    // ========= 交互 =========
    let started = false;
    let isDown=false, lastX=0, lastY=0, moved=0, tapStart=0;
    let rotYTarget = root.rotation.y;
    let rotXTarget = root.rotation.x;

    // 点击散开（无摄像头也能玩）
    let tapBoost = 0;

    function onDown(e){
      isDown=true; moved=0; tapStart=performance.now();
      const pt = e.touches ? e.touches[0] : e;
      lastX=pt.clientX; lastY=pt.clientY;
    }
    function onMove(e){
      if(!isDown) return;
      const pt = e.touches ? e.touches[0] : e;
      const dx = pt.clientX - lastX;
      const dy = pt.clientY - lastY;
      lastX=pt.clientX; lastY=pt.clientY;
      moved += Math.abs(dx)+Math.abs(dy);
      rotYTarget += dx * 0.010;
      rotXTarget += dy * 0.006;
      rotXTarget = Math.max(-0.55, Math.min(0.20, rotXTarget));
    }
    function onUp(){
      if(!isDown) return;
      isDown=false;
      const dt = performance.now() - tapStart;
      if(dt < 260 && moved < 18){
        tapBoost = 1.0;            // 立即散开
        uniforms.uFlash.value = 0.9;
      }
    }

    canvas.addEventListener("pointerdown", onDown, {passive:true});
    canvas.addEventListener("pointermove", onMove, {passive:true});
    canvas.addEventListener("pointerup", onUp, {passive:true});
    canvas.addEventListener("pointercancel", onUp, {passive:true});
    canvas.addEventListener("touchstart", onDown, {passive:true});
    canvas.addEventListener("touchmove", onMove, {passive:true});
    canvas.addEventListener("touchend", onUp, {passive:true});
    canvas.addEventListener("touchcancel", onUp, {passive:true});

    // ========= 散开/聚拢逻辑 =========
    let spread = 0; // 当前散开程度
    function motionToTarget(motion){
      // motion > thr 时开始散开，越大越散
      const x = (motion - cam.thr) / 14.0;
      return Math.max(0, Math.min(1, x));
    }

    // ========= 渲染 =========
    let t0=performance.now(), lastT=0;
    function animate(){
      requestAnimationFrame(animate);
      const t=(performance.now()-t0)/1000;
      const dt=Math.min(0.05, Math.max(0.001, t-lastT));
      lastT=t;

      uniforms.uTime.value = t;
      // 旋转驱动的色相偏移：转得越多，颜色越变；也叠一点时间流动
      if (uniforms.uHueShift) uniforms.uHueShift.value = root.rotation.y * 0.55 + t * 0.25;
      if(started) uniforms.uFadeIn.value = Math.min(1, uniforms.uFadeIn.value + 0.05);
      else uniforms.uFadeIn.value = 0;

      // 摄像头驱动：挥手散开，不挥聚拢
      let camTarget = 0;
      if(started && cam.enabled && cam.ready){
        const { motion, bias } = detectMotion();
        rotYTarget += bias * 0.10;
        camTarget = motionToTarget(motion);
      }

      // 点击驱动：给一个短暂散开，然后自动回去
      tapBoost = Math.max(0, tapBoost - dt*1.35);

      const target = Math.max(camTarget, tapBoost);
      spread += (target - spread) * 0.18;      // 平滑一点，不抽搐
      uniforms.uSpread.value = spread;

      // 小闪光尾巴
      uniforms.uFlash.value = Math.max(0, uniforms.uFlash.value - dt*1.8);

      root.rotation.y += (rotYTarget - root.rotation.y) * 0.14;
      root.rotation.x += (rotXTarget - root.rotation.x) * 0.12;

      star.scale.setScalar(0.92 + 0.12*Math.sin(t*2.2));

      camera3.lookAt(0,0,0);
      renderer.render(scene, camera3);

      if(DEBUG){
        debugEl.innerHTML =
          `started: ${started}<br/>`+
          `cam: ${cam.enabled && cam.ready}<br/>`+
          `motion: ${cam.lastMotion.toFixed(1)}<br/>`+
          `thr: ${cam.thr.toFixed(1)} (base ${cam.baseline.toFixed(1)})<br/>`+
          `spread: ${spread.toFixed(2)} (tap ${tapBoost.toFixed(2)})<br/>`+
          `hue: ${uniforms.uHueShift.value.toFixed(2)}<br/>`+
          `bias: ${cam.lastBias.toFixed(2)}<br/>`+
          `rotY: ${root.rotation.y.toFixed(2)} rotX: ${root.rotation.x.toFixed(2)}`;
      }
    }
    animate();

    // ========= 启动流程 =========
    async function startFlow(){
      const raw = (nameInput.value || "").trim();
      const who = raw ? raw : "你";

      try{

      await startCamera(); // 成功就挥手散开，不成功也可点击散开

      gate.classList.add("hide");
      await sleep(320);
      gate.style.display = "none";

      started = true;
      cornerTip.classList.add("on");

      await showSubtitle(`${who}，圣诞夜我在你身边。`, 28, 780);
      await showSubtitle(`你点亮我，我才有光。`, 28, 780);
      await showSubtitle(`挥手散开 · 不挥聚拢 · 没摄像头就轻点散开`, 20, 900);

      await hideSubs();
      tapBoost = 0.8; // 开场给一口气
      uniforms.uFlash.value = 0.9;
      }catch(err){
        console.error(err);
        // 如果点亮没反应，至少把原因写到字幕里
        await showSubtitle("点亮失败：请打开控制台看报错（常见是 shader/uniform 或三方资源加载失败）", 12, 1400);
      }
    }

    goBtn.addEventListener("click", startFlow);

    // 兜底：如果浏览器仍拦截自动播放，任意一次触碰/点击页面再试一次
    window.addEventListener("pointerdown", async ()=>{
      if(!musicOn) await tryPlayMusic();
    }, { passive:true, once:true });
    nameInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter") startFlow(); });
    setTimeout(()=>nameInput.focus(), 150);

    function onResize(){
      const w=window.innerWidth, h=window.innerHeight;
      renderer.setSize(w,h,false);
      camera3.aspect = w/h;
      camera3.updateProjectionMatrix();
    }
    window.addEventListener("resize", onResize);
    window.addEventListener("orientationchange", onResize);
  </script>
</body>
</html>
