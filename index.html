<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>3D 粒子圣诞树</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;}
    #hud{
      position:fixed;left:12px;top:12px;z-index:10;
      color:rgba(255,255,255,0.78);font:12px/1.3 system-ui,-apple-system,"PingFang SC";
      background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);
      padding:8px 10px;border-radius:12px;backdrop-filter:blur(8px);
    }
    #hud b{color:#fff}
  </style>
</head>
<body>
  <div id="hud">拖动旋转 · 轻点闪烁<br><b>3D 粒子圣诞树</b></div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.06);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 1.4, 7.2);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.6)); // 手机别开太高
renderer.setClearColor(0x000000, 1);
document.body.appendChild(renderer.domElement);

// ===== 后期发光 Bloom =====
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(
  new THREE.Vector2(innerWidth, innerHeight),
  1.25,   // strength
  0.9,    // radius
  0.08    // threshold（越低越容易发光）
);
composer.addPass(bloom);

// ===== 组：树 + 星 + 雪 =====
const world = new THREE.Group();
scene.add(world);

// 轻微“地面粒子”
const ground = makeGroundSparkles();
ground.position.y = -1.0;
world.add(ground);

// 粒子树
const tree = makeParticleTree();
tree.position.y = -0.8;
world.add(tree);

// 星星
const stars = makeStars(1100);
world.add(stars);

// 雪
const snow = makeSnow(520);
world.add(snow);

// 顶部星星（mesh）
const star = makeTopStar();
star.position.set(0, 2.9, 0);
world.add(star);

// ===== 简易触控旋转（不用 OrbitControls）=====
let dragging = false, lastX = 0, lastY = 0;
let rotY = 0, rotX = 0, targetRotY = 0, targetRotX = 0;

addEventListener("pointerdown", e => { dragging=true; lastX=e.clientX; lastY=e.clientY; }, {passive:true});
addEventListener("pointerup",   () => { dragging=false; }, {passive:true});
addEventListener("pointermove", e => {
  if(!dragging) return;
  const dx = (e.clientX - lastX) / innerWidth;
  const dy = (e.clientY - lastY) / innerHeight;
  lastX = e.clientX; lastY = e.clientY;
  targetRotY += dx * 2.2;
  targetRotX += dy * 1.2;
  targetRotX = Math.max(-0.45, Math.min(0.45, targetRotX));
}, {passive:true});

// 轻点让树“闪一下”
addEventListener("click", () => pulse = 1, {passive:true});

// ===== 动画 =====
let t = 0;
let pulse = 0;

function animate(){
  t += 0.016;
  pulse = Math.max(0, pulse - 0.04);

  // 平滑旋转
  rotY += (targetRotY - rotY) * 0.08;
  rotX += (targetRotX - rotX) * 0.08;
  world.rotation.y = rotY;
  world.rotation.x = rotX;

  // 树的“呼吸闪烁”
  tree.material.opacity = 0.92 + 0.08*Math.sin(t*1.3) + pulse*0.25;
  tree.material.size = baseTreeSize * (1.0 + 0.08*Math.sin(t*1.9) + pulse*0.25);

  // 星星闪一点
  stars.material.opacity = 0.55 + 0.25*Math.sin(t*0.5);

  // 雪飘落
  updateSnow(snow, t);

  // 顶星旋转
  star.rotation.y += 0.02;
  star.rotation.z += 0.01;

  composer.render();
  requestAnimationFrame(animate);
}
const baseTreeSize = tree.material.size;
requestAnimationFrame(animate);

addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
  bloom.setSize(innerWidth, innerHeight);
}, {passive:true});

// ======= 生成：粒子圣诞树 =======
function makeParticleTree(){
  // 手机性能：这个决定“密度”
  const LEVELS = 180;     // 越大越细腻
  const PER_LEVEL = 26;   // 每层点数
  const EXTRA_HELIX = 260;// 螺旋灯带点数

  const height = 3.6;
  const baseR  = 1.65;

  const positions = [];
  const colors = [];

  const greenA = new THREE.Color("#66ffb7");
  const greenB = new THREE.Color("#13d66f");
  const gold   = new THREE.Color("#ffd36a");
  const red    = new THREE.Color("#ff4d7a");
  const white  = new THREE.Color("#ffffff");

  // 主体：锥体内点云
  for(let i=0;i<LEVELS;i++){
    const u = i/(LEVELS-1);
    const y = u*height;
    const r = Math.pow(1-u, 1.12) * baseR;

    for(let k=0;k<PER_LEVEL;k++){
      const a = Math.random()*Math.PI*2;
      const rr = r * (0.35 + 0.75*Math.random());
      const x = Math.cos(a)*rr + (Math.random()-0.5)*0.05;
      const z = Math.sin(a)*rr + (Math.random()-0.5)*0.05;

      positions.push(x, y, z);

      // 颜色：底部更绿，上面更偏亮
      const c = greenA.clone().lerp(greenB, u);
      // 少量彩灯点缀
      const p = Math.random();
      if (p < 0.05) c.copy(red);
      else if (p < 0.10) c.copy(gold);
      else if (p < 0.115) c.copy(white);

      colors.push(c.r, c.g, c.b);
    }
  }

  // 螺旋灯带：让它像你图里那样“绕上去”
  const turns = 7.5;
  for(let i=0;i<EXTRA_HELIX;i++){
    const u = i/(EXTRA_HELIX-1);
    const y = u*height;
    const r = Math.pow(1-u, 1.05) * (baseR*0.92);
    const a = u * turns * Math.PI*2;

    const x = Math.cos(a)*r;
    const z = Math.sin(a)*r;
    positions.push(x, y, z);

    const c = new THREE.Color("#7CFF66").lerp(new THREE.Color("#FFF36A"), u*0.9);
    colors.push(c.r, c.g, c.b);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
  geo.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.055,
    vertexColors: true,
    transparent: true,
    opacity: 0.95,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    sizeAttenuation: true
  });

  const pts = new THREE.Points(geo, mat);
  pts.position.y = 0;
  return pts;
}

// 顶部星星（简单几何）
function makeTopStar(){
  const g = new THREE.IcosahedronGeometry(0.16, 0);
  const m = new THREE.MeshBasicMaterial({ color: 0xFFD36A });
  const s = new THREE.Mesh(g, m);
  return s;
}

// 星星背景
function makeStars(n){
  const positions = [];
  for(let i=0;i<n;i++){
    const r = 30 + Math.random()*70;
    const a = Math.random()*Math.PI*2;
    const b = Math.acos(THREE.MathUtils.randFloatSpread(2)); // roughly sphere
    const x = r * Math.sin(b) * Math.cos(a);
    const y = r * Math.cos(b) * 0.35 + 2.0; // 稍微抬高
    const z = r * Math.sin(b) * Math.sin(a);
    positions.push(x,y,z);
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({
    size: 0.06,
    color: 0xffffff,
    transparent: true,
    opacity: 0.65,
    depthWrite: false
  });
  return new THREE.Points(geo, mat);
}

// 雪
function makeSnow(n){
  const positions = [];
  const speeds = [];
  for(let i=0;i<n;i++){
    positions.push(
      THREE.MathUtils.randFloatSpread(12),
      Math.random()*6 - 0.2,
      THREE.MathUtils.randFloatSpread(12)
    );
    speeds.push(0.25 + Math.random()*0.75);
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
  geo.setAttribute("speed", new THREE.Float32BufferAttribute(speeds, 1));
  const mat = new THREE.PointsMaterial({
    size: 0.06,
    color: 0xffffff,
    transparent: true,
    opacity: 0.75,
    depthWrite: false
  });
  const pts = new THREE.Points(geo, mat);
  pts.userData.speeds = speeds;
  return pts;
}

function updateSnow(pts, tt){
  const pos = pts.geometry.attributes.position;
  const speeds = pts.geometry.attributes.speed;
  for(let i=0;i<pos.count;i++){
    pos.setY(i, pos.getY(i) - speeds.getX(i)*0.03);
    pos.setX(i, pos.getX(i) + Math.sin(tt*0.6 + i)*0.0008);
    if(pos.getY(i) < -1.0){
      pos.setY(i, 6.0 + Math.random()*1.5);
      pos.setX(i, THREE.MathUtils.randFloatSpread(12));
      pos.setZ(i, THREE.MathUtils.randFloatSpread(12));
    }
  }
  pos.needsUpdate = true;
}

// 地面粒子
function makeGroundSparkles(){
  const n = 600;
  const positions = [];
  for(let i=0;i<n;i++){
    const x = THREE.MathUtils.randFloatSpread(10);
    const z = THREE.MathUtils.randFloatSpread(10);
    const y = -0.02 + Math.random()*0.05;
    positions.push(x,y,z);
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({
    size: 0.05,
    color: 0x66ffb7,
    transparent: true,
    opacity: 0.35,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  return new THREE.Points(geo, mat);
}
</script>
</body>
</html>
