<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>圣诞夜 · 粒子贺卡</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --muted:rgba(255,255,255,.72);
      --stroke:rgba(255,255,255,.16);
      --shadow:0 18px 60px rgba(0,0,0,.55);
      --radius:18px;
    }
    *{ box-sizing:border-box; }
    html,body{
      height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family:-apple-system,BlinkMacSystemFont,"PingFang SC","Noto Sans SC","Microsoft YaHei",system-ui,Segoe UI,Roboto,Helvetica,Arial;
    }
    body{ overflow:hidden; }

    #stage{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      display:block;
      touch-action:none;
    }

    /* 摄像头输入隐藏 */
    video#cam{
      position:fixed;
      width:1px; height:1px;
      opacity:0;
      pointer-events:none;
      left:-10px; top:-10px;
    }

    /* 入口遮罩 */
    #gate{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:24px;
      background:radial-gradient(1200px 700px at 50% 40%, rgba(255,255,255,.07), rgba(0,0,0,1) 62%);
      z-index:10;
      opacity:1;
      transition:opacity .45s ease;
    }
    #gate.hide{ opacity:0; pointer-events:none; }

    .card{
      width:min(460px, 92vw);
      background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px 16px 16px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .title{
      font-size:16px; letter-spacing:.6px;
      color:rgba(255,255,255,.92);
      display:flex; align-items:center; gap:10px;
      margin:0 0 10px;
    }
    .badge{
      width:10px; height:10px; border-radius:50%;
      background:rgba(255,255,255,.88);
      box-shadow:0 0 18px rgba(255,255,255,.5);
      flex:none;
    }
    .hint{
      margin:0 0 12px;
      color:var(--muted);
      font-size:13px;
      line-height:1.55;
    }
    .row{ display:flex; gap:10px; align-items:center; }
    input{
      flex:1;
      background:rgba(0,0,0,.55);
      color:var(--fg);
      border:1px solid rgba(255,255,255,.18);
      border-radius:14px;
      padding:12px 12px;
      font-size:14px;
      outline:none;
    }
    input::placeholder{ color:rgba(255,255,255,.38); }
    button{
      background:rgba(255,255,255,.92);
      color:#000;
      border:none;
      border-radius:14px;
      padding:12px 14px;
      font-weight:900;
      font-size:14px;
      cursor:pointer;
      box-shadow:0 10px 30px rgba(255,255,255,.14);
    }
    button:active{ transform:translateY(1px); }

    /* 字幕条：滑入 -> 打字 -> 滑出 */
    #subs{
      position:fixed;
      left:50%;
      bottom:max(16px, env(safe-area-inset-bottom));
      transform:translateX(-50%);
      width:min(860px, 94vw);
      z-index:20;
      pointer-events:none;
      opacity:0;
      transition:opacity .22s ease;
    }
    #subs.on{ opacity:1; }
    .subline{
      background:rgba(0,0,0,.64);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:12px 14px;
      box-shadow:0 14px 50px rgba(0,0,0,.65);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      font-size:15px;
      line-height:1.6;
      letter-spacing:.2px;
      color:rgba(255,255,255,.94);
      text-shadow:0 2px 16px rgba(0,0,0,.9);
      min-height:48px;
      display:flex; align-items:center;

      transform:translateY(18px);
      opacity:0;
      transition:transform .32s cubic-bezier(.2,.9,.2,1), opacity .32s ease;
    }
    .subline.enter{ transform:translateY(0); opacity:1; }
    .subline.exit{ transform:translateY(18px); opacity:0; }

    .caret{
      display:inline-block;
      width:10px;
      margin-left:3px;
      opacity:.9;
      animation:blink 1s steps(1) infinite;
    }
    @keyframes blink { 50%{ opacity:0; } }

    /* 顶部提示 */
    #cornerTip{
      position:fixed;
      top:max(14px, env(safe-area-inset-top));
      left:50%;
      transform:translateX(-50%);
      z-index:15;
      opacity:0;
      transition:opacity .6s ease;
      pointer-events:none;
      display:flex;
      align-items:center;
      gap:10px;
      white-space:nowrap;
    }
    #cornerTip.on{ opacity:1; }

    .pill{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.35);
      color:rgba(255,255,255,.62);
      box-shadow:0 10px 30px rgba(0,0,0,.4);
      font-size:12px;
      letter-spacing:.3px;
      text-shadow:0 2px 16px rgba(0,0,0,.8);
    }
    .pill b{ color:rgba(255,255,255,.88); font-weight:900; }

    @media (prefers-reduced-motion: reduce){
      .subline{ transition:none; }
      #gate{ transition:none; }
      .caret{ animation:none; }
      #cornerTip{ transition:none; }
    }
  </style>
</head>

<body>
  <canvas id="stage"></canvas>
  <video id="cam" playsinline muted></video>

  <div id="gate">
    <div class="card">
      <div class="title"><span class="badge"></span>圣诞夜 · 粒子贺卡</div>
      <p class="hint">
        输入名字，点“点亮”。会尝试开启摄像头：你挥手就能触发星光炸开（不开也没关系，照样拖动旋转）。
        <br/>（摄像头需要 HTTPS 或 localhost）
      </p>
      <div class="row">
        <input id="name" maxlength="12" placeholder="输入名字（例如：小猫咪）" />
        <button id="go">点亮</button>
      </div>
    </div>
  </div>

  <div id="cornerTip">
    <span class="pill">拖动旋转 · 轻点炸开</span>
    <span class="pill" id="camStatus">摄像头：<b>未开启</b></span>
  </div>

  <div id="subs">
    <div class="subline" id="subline"></div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const canvas = document.getElementById("stage");
    const gate = document.getElementById("gate");
    const goBtn = document.getElementById("go");
    const nameInput = document.getElementById("name");
    const subs = document.getElementById("subs");
    const subline = document.getElementById("subline");
    const cornerTip = document.getElementById("cornerTip");
    const camEl = document.getElementById("cam");
    const camStatus = document.getElementById("camStatus");

    const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));

    async function showSubtitle(text, typeSpeed=28, hold=900){
      subs.classList.add("on");
      subline.classList.remove("exit");
      subline.classList.add("enter");
      subline.innerHTML = "";
      await sleep(240);

      const caret = document.createElement("span");
      caret.className = "caret";
      caret.textContent = "▍";

      for(let i=0;i<text.length;i++){
        subline.textContent = text.slice(0, i+1);
        subline.appendChild(caret);
        await sleep(typeSpeed);
      }
      subline.textContent = text;
      await sleep(hold);

      subline.classList.remove("enter");
      subline.classList.add("exit");
      await sleep(320);
    }

    async function hideSubs(){
      subline.classList.remove("enter");
      subline.classList.add("exit");
      await sleep(220);
      subs.classList.remove("on");
    }

    // ===================== 摄像头运动检测（挥手触发） =====================
    const cam = {
      enabled:false,
      ready:false,
      stream:null,
      w:112, h:84,          // 采样分辨率（更高更敏感，但更吃）
      c:null, ctx:null,
      prev:null,
      cooldown:0
    };

    function setCamStatus(text, ok=false){
      camStatus.innerHTML = `摄像头：<b>${text}</b>`;
      const b = camStatus.querySelector("b");
      b.style.color = ok ? "rgba(120,255,190,.92)" : "rgba(255,255,255,.88)";
      if(!ok && text.includes("拒绝")) b.style.color = "rgba(255,120,150,.92)";
      if(!ok && text.includes("需HTTPS")) b.style.color = "rgba(255,210,120,.92)";
    }

    async function startCamera(){
      if(!navigator.mediaDevices?.getUserMedia){
        setCamStatus("不支持", false);
        return false;
      }
      if(!window.isSecureContext){
        setCamStatus("需HTTPS", false);
        return false;
      }
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video:{ facingMode:"user", width:{ideal:640}, height:{ideal:480} },
          audio:false
        });
        cam.stream = stream;
        camEl.srcObject = stream;
        await camEl.play();

        cam.c = document.createElement("canvas");
        cam.c.width = cam.w;
        cam.c.height = cam.h;
        cam.ctx = cam.c.getContext("2d", { willReadFrequently:true });

        cam.prev = new Uint8Array(cam.w * cam.h);
        cam.ready = true;
        cam.enabled = true;
        setCamStatus("已开启", true);
        return true;
      }catch(_){
        setCamStatus("被拒绝", false);
        cam.ready = false;
        cam.enabled = false;
        return false;
      }
    }

    function stopCamera(){
      try{ cam.stream?.getTracks?.().forEach(t=>t.stop()); }catch(_){}
      cam.stream = null;
      cam.ready = false;
      cam.enabled = false;
      setCamStatus("未开启", false);
    }

    // 返回 {motion, bias}
    // motion：整体运动强度（越大越“挥手”）
    // bias：左右不均衡（>0右侧更动，<0左侧更动）
    function detectMotion(){
      if(!cam.ready || !cam.enabled) return { motion:0, bias:0 };

      cam.ctx.drawImage(camEl, 0, 0, cam.w, cam.h);
      const data = cam.ctx.getImageData(0, 0, cam.w, cam.h).data;

      let sum=0, sumL=0, sumR=0;
      const step = 2; // 2 像素采样一次
      for(let y=0;y<cam.h;y+=step){
        for(let x=0;x<cam.w;x+=step){
          const idx = y*cam.w + x;
          const p = idx*4;
          const lum = (data[p] + data[p+1] + data[p+2]) / 3;
          const prev = cam.prev[idx] || 0;
          const diff = Math.abs(lum - prev);
          cam.prev[idx] = lum;

          sum += diff;
          if(x < cam.w/2) sumL += diff;
          else sumR += diff;
        }
      }

      const samples = (Math.ceil(cam.h/step) * Math.ceil(cam.w/step));
      const motion = sum / samples;                     // 0..255
      const bias = sum > 1 ? (sumR - sumL) / sum : 0;   // -1..1
      return { motion, bias };
    }

    // ===================== Three.js 粒子树 =====================
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);

    const scene = new THREE.Scene();
    // 几乎不影响可见度的雾（别再把树雾没了）
    scene.fog = new THREE.Fog(0x000000, 14, 40);

    const camera3 = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 120);
    // 拉近一点 + 更聚焦
    camera3.position.set(0, 1.05, 7.2);

    const root = new THREE.Group();
    // 直接放大树：强到你闭眼都看得见
    root.scale.setScalar(1.28);
    scene.add(root);

    scene.add(new THREE.AmbientLight(0xffffff, 0.25));

    const HEIGHT = 4.6;
    const BASE_RADIUS = 2.2;
    const LAYERS = 7;

    const treeCols = ["#0B3D0B","#144514","#006400"].map(s=>new THREE.Color(s));
    const decorCols = ["#FFD36A","#D4AF37","#8B0000","#6AA7FF","#FF4FD8"].map(s=>new THREE.Color(s));
    const trunkCol = new THREE.Color("#3a241f");
    const ribbonCol = new THREE.Color("#D4AF37");
    const snowCol = new THREE.Color("#ffffff");

    function randn(){
      let u=0,v=0;
      while(u===0) u=Math.random();
      while(v===0) v=Math.random();
      return Math.sqrt(-2.0*Math.log(u))*Math.cos(2.0*Math.PI*v);
    }

    // 动态数组：leaf / decor / ribbon / trunk / snow
    const P=[], C=[], S=[], D=[], K=[], A=[], SP=[];
    function addPoint(x,y,z, color, scale, kind, alpha, speed=0){
      P.push(x,y,z);
      C.push(color.r,color.g,color.b);
      S.push(scale);
      const dir = new THREE.Vector3(x,y,z).normalize();
      D.push(dir.x,dir.y,dir.z);
      K.push(kind);
      A.push(alpha);
      SP.push(speed);
    }

    // leaves（更多点，让体积扎实）
    for(let i=0;i<12000;i++){
      const h = Math.random();                 // 0..1
      const base_r = (1 - h);
      const layer_cycle = (h * LAYERS) % 1;

      const r = base_r * 0.65 * (0.38 + 0.62 * Math.pow(1 - layer_cycle, 0.7));
      const theta = Math.random() * Math.PI * 2;

      const x = r * Math.cos(theta) + randn()*0.05;
      const z = r * Math.sin(theta) + randn()*0.05;
      const y = (h - 0.5) * HEIGHT;

      const col = treeCols[(Math.random()*treeCols.length)|0];
      const size = 0.65 + Math.random()*1.35;
      addPoint(x,y,z,col,size,0.0,0.95);
    }

    // trunk
    for(let i=0;i<1500;i++){
      const y = (-0.72 + Math.random()*0.28) * HEIGHT;
      const r = 0.12;
      const t = Math.random()*Math.PI*2;
      const x = Math.cos(t)*r + randn()*0.012;
      const z = Math.sin(t)*r + randn()*0.012;
      addPoint(x,y,z,trunkCol,1.35,3.0,1.0);
    }

    // decor
    for(let i=0;i<1050;i++){
      const h = Math.random()*0.96;
      const base_r = (1 - h);
      const layer_cycle = (h * LAYERS) % 1;
      const r = base_r * 0.70 * (0.36 + 0.64 * Math.pow(1 - layer_cycle, 0.72));
      const theta = Math.random()*Math.PI*2;

      const x = r*Math.cos(theta);
      const z = r*Math.sin(theta);
      const y = (h - 0.5)*HEIGHT;

      const col = decorCols[(Math.random()*decorCols.length)|0];
      const size = 1.45 + Math.random()*1.55;
      addPoint(x,y,z,col,size,1.0,1.0);
    }

    // ribbon (more)
    const ribbonN = 7800;
    for(let i=0;i<ribbonN;i++){
      const h = (i/(ribbonN-1))*0.96;
      const base_r = (1 - h) * 0.68 * 1.06;
      const theta = 10.5 * Math.PI * h;

      const x = base_r*Math.cos(theta);
      const z = base_r*Math.sin(theta);
      const y = (h - 0.5)*HEIGHT;

      addPoint(x,y,z,ribbonCol,1.05,2.0,0.92);
    }

    // snow
    for(let i=0;i<420;i++){
      const x = (Math.random()*2 - 1) * 1.35;
      const z = (Math.random()*2 - 1) * 1.35;
      const y0 = (-1.0 + Math.random()*2.4) * (HEIGHT*0.55);
      const speed = 0.28 + Math.random()*0.62;
      const size = 0.55 + Math.random()*1.55;
      addPoint(x,y0,z,snowCol,size,4.0,0.55 + Math.random()*0.35,speed);
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute("aBase",  new THREE.BufferAttribute(new Float32Array(P), 3));
    geometry.setAttribute("aColor", new THREE.BufferAttribute(new Float32Array(C), 3));
    geometry.setAttribute("aScale", new THREE.BufferAttribute(new Float32Array(S), 1));
    geometry.setAttribute("aDir",   new THREE.BufferAttribute(new Float32Array(D), 3));
    geometry.setAttribute("aKind",  new THREE.BufferAttribute(new Float32Array(K), 1));
    geometry.setAttribute("aAlpha", new THREE.BufferAttribute(new Float32Array(A), 1));
    geometry.setAttribute("aSpeed", new THREE.BufferAttribute(new Float32Array(SP), 1));

    const uniforms = {
      uTime:   { value: 0 },
      uSize:   { value: 7.6 },   // 关键：更强、更大
      uBurst:  { value: 0 },
      uFadeIn: { value: 0 }
    };

    const material = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      blending:THREE.AdditiveBlending, // 关键：发光叠加
      uniforms,
      vertexShader: `
        attribute vec3 aBase;
        attribute vec3 aColor;
        attribute float aScale;
        attribute vec3 aDir;
        attribute float aKind;
        attribute float aAlpha;
        attribute float aSpeed;

        varying vec3 vColor;
        varying float vTw;
        varying float vAlpha;
        varying float vKind;

        uniform float uTime;
        uniform float uSize;
        uniform float uBurst;
        uniform float uFadeIn;

        void main(){
          vColor = aColor;
          vKind = aKind;
          vAlpha = aAlpha;

          float seed = aBase.y*2.6 + aBase.x*3.1 + aBase.z*2.9;

          float twBase = 0.55 + 0.45 * sin(uTime*1.7 + seed);
          float amp = 0.22;
          if (aKind < 0.5) amp = 0.22;            // tree
          else if (aKind < 1.5) amp = 0.48;       // decor
          else if (aKind < 2.5) amp = 0.34;       // ribbon
          else if (aKind < 3.5) amp = 0.10;       // trunk
          else amp = 0.12;                         // snow
          vTw = 0.76 + twBase * amp;

          vec3 p = aBase;

          if (aKind > 3.5) {
            float fall = mod(uTime * aSpeed, 6.0);
            p.y = aBase.y - fall;
            if (p.y < -3.35) p.y += 6.0;
          } else {
            p += aDir * (uBurst * 1.45); // 关键：炸开更远
          }

          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          float distScale = 260.0 / max(1.0, -mvPosition.z); // 关键：点更明显

          float ps = aScale * uSize * distScale * vTw * uFadeIn;
          gl_PointSize = clamp(ps, 1.0, 18.0); // 关键：更大但有限制
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec3 vColor;
        varying float vTw;
        varying float vAlpha;
        varying float vKind;
        uniform float uFadeIn;

        void main(){
          vec2 uv = gl_PointCoord.xy - 0.5;
          float d = length(uv);

          // 核心更大，光晕更厚，但仍控制白化
          float core = smoothstep(0.32, 0.0, d);
          float halo = smoothstep(0.62, 0.24, d) * 0.26;

          float a = (core * 0.92 + halo) * vAlpha * (0.78 + vTw*0.32) * uFadeIn;

          float bright = 1.0;
          if (vKind > 0.5 && vKind < 1.5) bright = 1.55;      // decor
          else if (vKind > 1.5 && vKind < 2.5) bright = 1.25; // ribbon
          else if (vKind > 2.5 && vKind < 3.5) bright = 0.80; // trunk
          else if (vKind > 3.5) bright = 1.05;                // snow

          vec3 col = vColor * bright;

          if (a < 0.004) discard;
          gl_FragColor = vec4(col, a);
        }
      `
    });

    const points = new THREE.Points(geometry, material);
    root.add(points);

    // 顶部星（更亮一点）
    const star = new THREE.Mesh(
      new THREE.SphereGeometry(0.065, 16, 16),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    star.position.set(0, HEIGHT*0.52 + 0.28, 0);
    root.add(star);

    root.rotation.y = 0.35;

    // ===================== 互动（拖动/轻点） =====================
    let started = false;
    let isDown = false;
    let lastX = 0;
    let rotTarget = root.rotation.y;
    let tapStart = 0;
    let moved = 0;

    function onDown(e){
      isDown = true;
      moved = 0;
      tapStart = performance.now();
      lastX = (e.touches ? e.touches[0].clientX : e.clientX);
    }
    function onMove(e){
      if(!isDown) return;
      const x = (e.touches ? e.touches[0].clientX : e.clientX);
      const dx = x - lastX;
      lastX = x;
      moved += Math.abs(dx);
      rotTarget += dx * 0.006;
    }
    function onUp(){
      if(!isDown) return;
      isDown = false;
      const dt = performance.now() - tapStart;
      if(dt < 230 && moved < 10) burstPulse();
    }

    canvas.addEventListener("pointerdown", onDown, { passive:true });
    window.addEventListener("pointermove", onMove, { passive:true });
    window.addEventListener("pointerup", onUp, { passive:true });
    canvas.addEventListener("touchstart", onDown, { passive:true });
    window.addEventListener("touchmove", onMove, { passive:true });
    window.addEventListener("touchend", onUp, { passive:true });

    let burstV = 0, burstT = 0;
    function burstPulse(){ burstT = 1; }

    // ===================== 渲染 + 摄像头控制 =====================
    let t0 = performance.now();
    let lastT = 0;

    function animate(){
      requestAnimationFrame(animate);
      const t = (performance.now() - t0) / 1000;
      const dt = Math.min(0.05, Math.max(0.001, t - lastT));
      lastT = t;

      uniforms.uTime.value = t;

      if(started) uniforms.uFadeIn.value = Math.min(1, uniforms.uFadeIn.value + 0.03);
      else uniforms.uFadeIn.value = 0;

      // 摄像头挥手触发
      if(started && cam.enabled && cam.ready){
        cam.cooldown = Math.max(0, cam.cooldown - dt);

        const { motion, bias } = detectMotion();

        // 阈值：更灵敏一点（树强了，挥手反馈也要强）
        const THRESH = 14.5;

        // 左右挥动 -> 旋转更明显
        rotTarget += bias * 0.08;

        // 大幅运动 -> 炸开
        if(motion > THRESH && cam.cooldown <= 0){
          burstPulse();
          cam.cooldown = 0.38;
        }
      }

      root.rotation.y += (rotTarget - root.rotation.y) * 0.09;
      root.rotation.y += Math.sin(t*0.18) * 0.0008;

      // 星星呼吸
      star.scale.setScalar(0.92 + 0.10*Math.sin(t*2.2));

      // 炸开动画（更“啪”）
      if(burstT > 0){
        burstV = Math.min(1, burstV + 0.22);
        if(burstV >= 1) burstT = -1;
      }else if(burstT < 0){
        burstV = Math.max(0, burstV - 0.13);
        if(burstV <= 0) burstT = 0;
      }
      uniforms.uBurst.value = burstV;

      renderer.render(scene, camera3);
    }
    animate();

    // ===================== 启动流程 =====================
    async function startFlow(){
      const raw = (nameInput.value || "").trim();
      const who = raw ? raw : "你";

      // 点击触发摄像头授权
      await startCamera();

      gate.classList.add("hide");
      await sleep(380);
      gate.style.display = "none";

      await showSubtitle(`${who}，圣诞夜我在你身边。`, 28, 900);
      await showSubtitle(`你点亮我，我才有光。`, 28, 900);

      if(cam.enabled && cam.ready){
        await showSubtitle(`挥手触发星光炸开，或者拖动旋转这棵树。`, 24, 850);
      }else{
        await showSubtitle(`拖动旋转，轻点让星光炸开。`, 24, 850);
      }

      started = true;
      cornerTip.classList.add("on");
      await hideSubs();
    }

    goBtn.addEventListener("click", startFlow);
    nameInput.addEventListener("keydown", (e)=>{ if(e.key === "Enter") startFlow(); });
    setTimeout(()=> nameInput.focus(), 180);

    function onResize(){
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera3.aspect = w / h;
      camera3.updateProjectionMatrix();
    }
    window.addEventListener("resize", onResize);
    window.addEventListener("orientationchange", onResize);

    document.addEventListener("visibilitychange", ()=>{
      if(document.hidden) stopCamera();
    });
  </script>
</body>
</html>
